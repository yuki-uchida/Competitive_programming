m, n = map(int, input().split())
# m**nを10**9+7


def modpow(a, n, mod):
    res = 1
    # 45 = 101101
    # ここでいう、1X11X1の部分飲み計算すれば良い
    # a**45 = a**32 + a**8 + a**4 + a**1なので、これだけ計算すれば良い
    # そしてそのためには、45を2進数に変えて、右ビットシフトしていけばok
    # なので、n >>= 1をする
    # ex)45,22,11,5,2,1
    while (n > 0):
        print(n, a, res)
        # 3&1みたいな論理積とった結果、両方1のものがあった場合にresにたす
        if n & 1:
            res = res * a % mod
        # a = 掛け算の結果を更新する。
        # a*b の mod(c)は。a mod(c)*b mod(c)と同じなので、掛け算するaもmodをとっていく
        a = a * a % mod
        # n>>1で、1桁ずつ減らしていく
        # 101101 > 10110みたいな
        # 先頭の1文字が減るわけではない。45->45-32みたいな感じではない
        # n=n>>1をすることで二進法展開ができる
        n = n >> 1
    return res


print(modpow(m, n, 10**9 + 7))
